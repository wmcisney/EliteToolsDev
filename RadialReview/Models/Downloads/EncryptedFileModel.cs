using FluentNHibernate.Mapping;
using RadialReview.Models.Interfaces;
using System;

namespace RadialReview.Models.Downloads {

	public enum EncryptionType {
		None = 0
	}

	public enum FileOrigin {
		Uploaded = 0,
		UserGenerate = 1,
		AutoGenerated = 2
	}
	public enum FileOutputMethod{
		//Do not edit name, only append. Literals used in JS
		Download = 0,
		Print = 1,
		Save = 2
	}

	public static class FileOriginExtensions {
		public static bool IsGenerated(this FileOrigin origin) {
			return origin == FileOrigin.UserGenerate || origin == FileOrigin.AutoGenerated;
		}
	}

	public class EncryptedFileModel {
		public virtual long Id { get; set; }
		public virtual string FilePath { get; set; }
		public virtual string FileName { get; set; }
		public virtual string FileType { get; set; }

		public virtual string FileDescription { get; set; }
		public virtual long CreatorId { get; set; }
		public virtual long OrgId { get; set; }
		public virtual DateTime CreateTime { get; set; }
		public virtual DateTime? DeleteTime { get; set; }
		public virtual EncryptionType EncryptionType { get; set; }
		public virtual string EncryptionKey { get; set; }

		public virtual bool Generating { get; set; }
		public virtual FileOrigin FileOrigin { get; set; }
		public virtual FileOutputMethod FileOutputMethod { get; set; }

		public virtual bool Complete { get; set; }
		public virtual long Size { get; set; }



		public EncryptedFileModel() {
			CreateTime = DateTime.UtcNow;
			FilePath = "" + Guid.NewGuid();
			EncryptionKey = "" + Guid.NewGuid();
		}

		public class Map : ClassMap<EncryptedFileModel> {
			public Map() {
				Id(x => x.Id);
				Map(x => x.CreateTime);
				Map(x => x.DeleteTime);
				Map(x => x.FilePath);
				Map(x => x.FileName);
				Map(x => x.FileType);
				Map(x => x.FileDescription);

				Map(x => x.OrgId);
				Map(x => x.CreatorId);
				Map(x => x.EncryptionType).CustomType<EncryptionType>();
				Map(x => x.EncryptionKey);

				Map(x => x.Generating);
				Map(x => x.FileOrigin).CustomType<FileOrigin>();
				Map(x => x.Complete);
				Map(x => x.Size);

				Map(x => x.FileOutputMethod).CustomType<FileOutputMethod>();
			}
		}
	}


	public class TagModel {
		private TagModel(string tag, ForModel forModel) {
			Tag = tag;
			ForModel = forModel;
		}

		public string Tag { get; private set; }
		public ForModel ForModel { get; private set; }

		public static TagModel Create(string tag) {
			return new TagModel(tag, null);
		}

		public static TagModel Create<T>(long id,string subtag) where T : ILongIdentifiable{
			return new TagModel(subtag, ForModel.Create<T>(id));
		}

	}

	public class EncryptedFileTagModel {
		public virtual long Id { get; set; }
		public virtual long FileId { get; set; }
		public virtual string Tag { get; set; }
		public virtual ForModel ForModel { get; set; }
		public virtual DateTime CreateTime { get; set; }
		public virtual DateTime? DeleteTime { get; set; }

		public EncryptedFileTagModel() {
			CreateTime = DateTime.UtcNow;
		}

		public class Map : ClassMap<EncryptedFileTagModel> {
			public Map() {
				Id(x => x.Id);
				Map(x => x.FileId);
				Map(x => x.Tag);
				Map(x => x.CreateTime);
				Map(x => x.DeleteTime);
				Component(x => x.ForModel).ColumnPrefix("ForModel_");


			}
		}
	}



	public class EncryptedFileAccessModel {
		public virtual long Id { get; set; }
		public virtual long FileId { get; set; }
		public virtual long UserId { get; set; }
		public virtual DateTime CreateTime { get; set; }

		public EncryptedFileAccessModel() {
			CreateTime = DateTime.UtcNow;
		}

		public class Map : ClassMap<EncryptedFileAccessModel> {
			public Map() {
				Id(x => x.Id);
				Map(x => x.FileId);
				Map(x => x.UserId);
				Map(x => x.CreateTime);

			}
		}
	}


}